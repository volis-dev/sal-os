import { config } from 'dotenv'
import { createClient } from '@supabase/supabase-js'

// Load environment variables
config({ path: '.env.local' })

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

interface TableInfo {
  tableName: string
  exists: boolean
  policies: PolicyInfo[]
  hasSelect: boolean
  hasInsert: boolean
  hasUpdate: boolean
  hasDelete: boolean
  complete: boolean
}

interface PolicyInfo {
  tablename: string
  policyname: string
  permissive: string
  roles: string[]
  cmd: string
  qual: string
  with_check: string
}

interface AuthCheckInfo {
  exists: boolean
  definition: string | null
}

class DatabasePolicyAudit {
  private supabase: any

  constructor() {
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing environment variables')
    }
    this.supabase = createClient(supabaseUrl, supabaseKey)
  }

  async runDatabaseAudit() {
    console.log('üîç SAL OS DATABASE POLICY AUDIT')
    console.log('===============================')
    console.log(`URL: ${supabaseUrl}`)
    console.log(`Key: ${supabaseKey ? supabaseKey.substring(0, 20) + '...' : 'undefined'}`)
    console.log('')

    await this.checkAuthCheckFunction()
    await this.listExistingTables()
    await this.auditRLSPolicies()
    await this.testUnauthenticatedAccess()
    await this.generatePolicySummary()
  }

  private async checkAuthCheckFunction() {
    console.log('1Ô∏è‚É£ AUTH_CHECK() FUNCTION VERIFICATION')
    console.log('=====================================')
    
    try {
      // Check if auth_check function exists
      const { data: functionData, error: functionError } = await this.supabase
        .rpc('exec_sql', {
          sql: `
            SELECT 
              proname, 
              prosrc,
              pg_get_functiondef(oid) as definition
            FROM pg_proc 
            WHERE proname = 'auth_check'
          `
        })

      if (functionError) {
        console.log(`‚ùå Error checking auth_check function: ${functionError.message}`)
        return
      }

      if (functionData && functionData.length > 0) {
        const func = functionData[0]
        console.log('‚úÖ auth_check() function exists')
        console.log(`üìù Function name: ${func.proname}`)
        console.log(`üìù Function source: ${func.prosrc}`)
        console.log(`üìù Full definition:`)
        console.log(func.definition)
      } else {
        console.log('‚ùå auth_check() function does not exist')
      }

      // Test the function directly
      console.log('\nüß™ Testing auth_check() function:')
      try {
        const { data: testData, error: testError } = await this.supabase
          .rpc('auth_check')

        if (testError) {
          console.log(`‚úÖ Function throws error as expected: ${testError.message}`)
        } else {
          console.log('‚ùå Function should throw error but returned data')
        }
      } catch (error) {
        console.log(`‚ö†Ô∏è Function test error: ${error}`)
      }

    } catch (error) {
      console.log(`‚ùå Function verification failed: ${error}`)
    }
  }

  private async listExistingTables() {
    console.log('\n2Ô∏è‚É£ EXISTING TABLES IN PUBLIC SCHEMA')
    console.log('====================================')
    
    try {
      const { data: tables, error } = await this.supabase
        .rpc('exec_sql', {
          sql: `
            SELECT tablename 
            FROM pg_tables 
            WHERE schemaname = 'public' 
            ORDER BY tablename
          `
        })

      if (error) {
        console.log(`‚ùå Error listing tables: ${error.message}`)
        return
      }

      console.log(`üìã Found ${tables.length} tables in public schema:`)
      tables.forEach((table: any, index: number) => {
        console.log(`  ${index + 1}. ${table.tablename}`)
      })

      // Expected tables for comparison
      const expectedTables = [
        'journal_entries',
        'vocabulary_words', 
        'tasks',
        'books',
        'life_arenas',
        'growth_goals',
        'journey_maps',
        'vocabulary_reviews',
        'task_time_logs',
        'book_notes',
        'goal_progress',
        'arena_metrics',
        'journey_waypoints',
        'vocabulary_sources',
        'task_categories',
        'book_categories'
      ]

      console.log('\nüìä TABLE COMPARISON:')
      console.log(`Expected: ${expectedTables.length} tables`)
      console.log(`Found: ${tables.length} tables`)

      const existingTableNames = tables.map((t: any) => t.tablename)
      const missingTables = expectedTables.filter(t => !existingTableNames.includes(t))
      const extraTables = existingTableNames.filter((t: string) => !expectedTables.includes(t))

      if (missingTables.length > 0) {
        console.log(`\n‚ùå Missing tables (${missingTables.length}):`)
        missingTables.forEach(table => console.log(`  - ${table}`))
      }

      if (extraTables.length > 0) {
        console.log(`\n‚ûï Extra tables (${extraTables.length}):`)
        extraTables.forEach((table: string) => console.log(`  - ${table}`))
      }

    } catch (error) {
      console.log(`‚ùå Table listing failed: ${error}`)
    }
  }

  private async auditRLSPolicies() {
    console.log('\n3Ô∏è‚É£ RLS POLICY AUDIT')
    console.log('====================')
    
    try {
      const { data: policies, error } = await this.supabase
        .rpc('exec_sql', {
          sql: `
            SELECT 
              tablename,
              policyname,
              permissive,
              roles,
              cmd,
              qual,
              with_check
            FROM pg_policies 
            WHERE schemaname = 'public'
            ORDER BY tablename, cmd
          `
        })

      if (error) {
        console.log(`‚ùå Error fetching policies: ${error.message}`)
        return
      }

      console.log(`üìã Found ${policies.length} RLS policies:`)
      
      if (policies.length === 0) {
        console.log('‚ùå No RLS policies found!')
        return
      }

      // Group policies by table
      const policiesByTable = policies.reduce((acc: any, policy: any) => {
        if (!acc[policy.tablename]) {
          acc[policy.tablename] = []
        }
        acc[policy.tablename].push(policy)
        return acc
      }, {})

      Object.entries(policiesByTable).forEach(([tableName, tablePolicies]: [string, any]) => {
        console.log(`\nüìã ${tableName} (${tablePolicies.length} policies):`)
        tablePolicies.forEach((policy: any) => {
          console.log(`  üîí ${policy.cmd.toUpperCase()}: ${policy.policyname}`)
          console.log(`     Roles: ${policy.roles.join(', ')}`)
          console.log(`     Qual: ${policy.qual || 'N/A'}`)
          console.log(`     With Check: ${policy.with_check || 'N/A'}`)
        })
      })

    } catch (error) {
      console.log(`‚ùå Policy audit failed: ${error}`)
    }
  }

  private async testUnauthenticatedAccess() {
    console.log('\n4Ô∏è‚É£ UNAUTHENTICATED ACCESS TEST')
    console.log('===============================')
    
    // Ensure we're unauthenticated
    await this.supabase.auth.signOut()
    
    try {
      // Get list of existing tables
      const { data: tables, error: tableError } = await this.supabase
        .rpc('exec_sql', {
          sql: `
            SELECT tablename 
            FROM pg_tables 
            WHERE schemaname = 'public' 
            ORDER BY tablename
          `
        })

      if (tableError) {
        console.log(`‚ùå Error getting tables: ${tableError.message}`)
        return
      }

      console.log('üß™ Testing unauthenticated SELECT access:')
      
      for (const table of tables) {
        const tableName = table.tablename
        console.log(`\nüìã Testing ${tableName}:`)
        
        try {
          const { data, error } = await this.supabase
            .from(tableName)
            .select('id')
            .limit(1)

          if (error) {
            console.log(`  ‚ùå Error: ${error.message}`)
            if (error.message.includes('row-level security policy')) {
              console.log(`    ‚úÖ RLS policy is blocking access`)
            } else if (error.message.includes('Authentication required')) {
              console.log(`    ‚úÖ auth_check() function is blocking access`)
            } else {
              console.log(`    ‚ö†Ô∏è Unexpected error type`)
            }
          } else {
            console.log(`  ‚ö†Ô∏è No error returned - returned ${data?.length || 0} rows`)
            if (data && data.length > 0) {
              console.log(`    üö® CRITICAL: Data exposed without authentication!`)
            }
          }
        } catch (error) {
          console.log(`  ‚ùå Test failed: ${error}`)
        }
      }

    } catch (error) {
      console.log(`‚ùå Unauthenticated access test failed: ${error}`)
    }
  }

  private async generatePolicySummary() {
    console.log('\n5Ô∏è‚É£ POLICY SUMMARY REPORT')
    console.log('=========================')
    
    try {
      // Get all tables
      const { data: tables, error: tableError } = await this.supabase
        .rpc('exec_sql', {
          sql: `
            SELECT tablename 
            FROM pg_tables 
            WHERE schemaname = 'public' 
            ORDER BY tablename
          `
        })

      if (tableError) {
        console.log(`‚ùå Error getting tables: ${tableError.message}`)
        return
      }

      // Get all policies
      const { data: policies, error: policyError } = await this.supabase
        .rpc('exec_sql', {
          sql: `
            SELECT 
              tablename,
              cmd
            FROM pg_policies 
            WHERE schemaname = 'public'
          `
        })

      if (policyError) {
        console.log(`‚ùå Error getting policies: ${policyError.message}`)
        return
      }

      // Analyze each table
      const tableAnalysis: TableInfo[] = []
      
      for (const table of tables) {
        const tableName = table.tablename
        const tablePolicies = policies.filter((p: any) => p.tablename === tableName)
        
        const analysis: TableInfo = {
          tableName,
          exists: true,
          policies: [],
          hasSelect: tablePolicies.some((p: any) => p.cmd === 'SELECT'),
          hasInsert: tablePolicies.some((p: any) => p.cmd === 'INSERT'),
          hasUpdate: tablePolicies.some((p: any) => p.cmd === 'UPDATE'),
          hasDelete: tablePolicies.some((p: any) => p.cmd === 'DELETE'),
          complete: false
        }
        
        analysis.complete = analysis.hasSelect && analysis.hasInsert && analysis.hasUpdate && analysis.hasDelete
        tableAnalysis.push(analysis)
      }

      // Summary statistics
      const totalTables = tableAnalysis.length
      const tablesWithPolicies = tableAnalysis.filter(t => t.policies.length > 0).length
      const completeTables = tableAnalysis.filter(t => t.complete).length
      const incompleteTables = tableAnalysis.filter(t => !t.complete && (t.hasSelect || t.hasInsert || t.hasUpdate || t.hasDelete)).length
      const noPoliciesTables = tableAnalysis.filter(t => !t.hasSelect && !t.hasInsert && !t.hasUpdate && !t.hasDelete).length

      console.log(`\nüìä POLICY COVERAGE SUMMARY:`)
      console.log(`Total tables: ${totalTables}`)
      console.log(`Tables with any policies: ${tablesWithPolicies}`)
      console.log(`Tables with complete policies: ${completeTables}`)
      console.log(`Tables with incomplete policies: ${incompleteTables}`)
      console.log(`Tables with no policies: ${noPoliciesTables}`)

      // Detailed breakdown
      console.log(`\nüìã DETAILED BREAKDOWN:`)
      
      if (completeTables > 0) {
        console.log(`\n‚úÖ COMPLETE TABLES (${completeTables}):`)
        tableAnalysis.filter(t => t.complete).forEach(t => {
          console.log(`  - ${t.tableName}: SELECT ‚úÖ INSERT ‚úÖ UPDATE ‚úÖ DELETE ‚úÖ`)
        })
      }

      if (incompleteTables > 0) {
        console.log(`\n‚ö†Ô∏è INCOMPLETE TABLES (${incompleteTables}):`)
        tableAnalysis.filter(t => !t.complete && (t.hasSelect || t.hasInsert || t.hasUpdate || t.hasDelete)).forEach(t => {
          const policies: string[] = []
          if (t.hasSelect) policies.push('SELECT')
          if (t.hasInsert) policies.push('INSERT')
          if (t.hasUpdate) policies.push('UPDATE')
          if (t.hasDelete) policies.push('DELETE')
          console.log(`  - ${t.tableName}: ${policies.join(' ‚úÖ ')} ‚ùå Missing: ${['SELECT', 'INSERT', 'UPDATE', 'DELETE'].filter(p => !policies.includes(p)).join(', ')}`)
        })
      }

      if (noPoliciesTables > 0) {
        console.log(`\n‚ùå NO POLICIES (${noPoliciesTables}):`)
        tableAnalysis.filter(t => !t.hasSelect && !t.hasInsert && !t.hasUpdate && !t.hasDelete).forEach(t => {
          console.log(`  - ${t.tableName}: No RLS policies at all`)
        })
      }

      // Recommendations
      console.log(`\nüìù RECOMMENDATIONS:`)
      
      if (noPoliciesTables > 0) {
        console.log(`üö® CRITICAL: ${noPoliciesTables} tables have no RLS policies`)
        console.log(`   - These tables are completely unprotected`)
        console.log(`   - Immediate action required`)
      }
      
      if (incompleteTables > 0) {
        console.log(`üîß INCOMPLETE: ${incompleteTables} tables have partial policies`)
        console.log(`   - Add missing policies for complete protection`)
      }
      
      if (completeTables === totalTables) {
        console.log(`‚úÖ EXCELLENT: All tables have complete RLS policies`)
      }

    } catch (error) {
      console.log(`‚ùå Policy summary generation failed: ${error}`)
    }
  }
}

// Run the database policy audit
async function runDatabasePolicyAudit() {
  try {
    const audit = new DatabasePolicyAudit()
    await audit.runDatabaseAudit()
  } catch (error) {
    console.error('‚ùå Database policy audit failed to start:', error)
    process.exit(1)
  }
}

runDatabasePolicyAudit()
  .then(() => {
    console.log('\nüèÅ Database policy audit complete!')
    process.exit(0)
  })
  .catch((error) => {
    console.error('‚ùå Database policy audit failed:', error)
    process.exit(1)
  }) 